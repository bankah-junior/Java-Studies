### âœ… **1. Understand the Problem First**

*   Read the problem **twice** before jumping to code.
*   Identify:
    *   **Input format**
    *   **Output format**
    *   **Constraints** (e.g., size of array, time limits)
*   Ask: *What is being asked?* and *What edge cases exist?*

***

### âœ… **2. Break It Down**

*   Convert the problem into **smaller subproblems**.
*   Example: For "Find the longest palindrome substring," first think:
    *   How to check if a substring is a palindrome?
    *   How to iterate through all substrings efficiently?

***

### âœ… **3. Start with Brute Force**

*   Write the simplest solution first (even if inefficient).
*   This helps you **understand the logic** before optimizing.

***

### âœ… **4. Use Patterns**

*   Many problems follow common patterns:
    *   **Sliding Window** â†’ Subarrays, strings
    *   **Two Pointers** â†’ Sorted arrays, linked lists
    *   **Binary Search** â†’ Sorted data, optimization problems
    *   **Hashing** â†’ Frequency count, duplicates
    *   **Recursion + DP** â†’ Optimization, counting problems

***

### âœ… **5. Dry Run with Examples**

*   Take **small test cases** and manually compute the answer.
*   Helps catch logical errors early.

***

### âœ… **6. Optimize Step by Step**

*   After brute force:
    *   Reduce **time complexity** (e.g., from O(nÂ²) to O(n log n))
    *   Reduce **space complexity** if possible.

***

### âœ… **7. Memorize Common Complexity Benchmarks**

*   O(n log n) â†’ Sorting
*   O(nÂ²) â†’ Nested loops
*   O(log n) â†’ Binary search
*   O(2^n) â†’ Recursion without memoization

***

### âœ… **8. Use Helper Functions**

*   Break code into **small reusable functions** for clarity.

***

### âœ… **9. Practice Edge Cases**

*   Empty input
*   Single element
*   Large input
*   Negative numbers / duplicates

***

### âœ… **10. Learn Debugging Tricks**

*   Print intermediate results.
*   Use **assertions** for expected outputs.
*   Use **visualization tools** for recursion and trees.

***

ðŸ”¥ **Pro Tip:** Always ask yourself:

*   Can I use **sorting**, **hashing**, or **binary search**?
*   Is there a **mathematical formula** that simplifies this?
*   Can I **reduce space** by using variables instead of data structures?