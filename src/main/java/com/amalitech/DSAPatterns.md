### âœ… **1. Sliding Window**

Used for problems involving subarrays or substrings.

*   **Example Problems:**
    *   Find the maximum sum of a subarray of size `k`.
    *   Longest substring without repeating characters.
*   **Idea:** Maintain a window and slide it across the array/string.

***

### âœ… **2. Two Pointers**

Efficient for sorted arrays or linked lists.

*   **Example Problems:**
    *   Pair with a given sum in a sorted array.
    *   Remove duplicates from a sorted array.
*   **Idea:** Use two pointers moving inward or outward to reduce complexity.

***

### âœ… **3. Fast & Slow Pointers (Floydâ€™s Cycle)**

Detect cycles in linked lists or arrays.

*   **Example Problems:**
    *   Detect a cycle in a linked list.
    *   Find the middle of a linked list.
*   **Idea:** One pointer moves twice as fast as the other.

***

### âœ… **4. Binary Search**

Used for searching or optimization problems.

*   **Example Problems:**
    *   Search in a sorted array.
    *   Find the square root of a number.
    *   Minimum capacity to ship packages within `D` days.
*   **Idea:** Divide and conquer by halving the search space.

***

### âœ… **5. Hashing**

For quick lookups and frequency counts.

*   **Example Problems:**
    *   Two Sum.
    *   Find duplicates in an array.
*   **Idea:** Use hash maps or sets for O(1) average lookup.

***

### âœ… **6. Prefix Sum / Difference Array**

For range queries and cumulative sums.

*   **Example Problems:**
    *   Range sum queries.
    *   Subarray sum equals `k`.
*   **Idea:** Precompute sums to answer queries in O(1).

***

### âœ… **7. Recursion + Backtracking**

Used for exhaustive search problems.

*   **Example Problems:**
    *   N-Queens.
    *   Generate all subsets or permutations.
*   **Idea:** Explore all possibilities and backtrack when needed.

***

### âœ… **8. Dynamic Programming (DP)**

For optimization and overlapping subproblems.

*   **Example Problems:**
    *   Fibonacci sequence.
    *   Knapsack problem.
    *   Longest Common Subsequence.
*   **Idea:** Store intermediate results to avoid recomputation.

***

### âœ… **9. Greedy**

Make the locally optimal choice at each step.

*   **Example Problems:**
    *   Activity selection.
    *   Minimum number of coins for change.
*   **Idea:** Works when local optimum leads to global optimum.

***

### âœ… **10. Graph Traversal**

DFS, BFS for graph/tree problems.

*   **Example Problems:**
    *   Shortest path in an unweighted graph (BFS).
    *   Detect cycles in a graph.
*   **Idea:** Explore nodes systematically.

***

### âœ… **11. Heap / Priority Queue**

For problems involving top-k or scheduling.

*   **Example Problems:**
    *   Find the k largest elements.
    *   Merge k sorted lists.
*   **Idea:** Use min-heap or max-heap for efficient retrieval.

***

### âœ… **12. Bit Manipulation**

For problems involving binary representation.

*   **Example Problems:**
    *   Find the single number in an array.
    *   Count set bits.
*   **Idea:** Use bitwise operators for efficiency.

***

ðŸ”¥ **Pro Tip:** Most problems fall under these patterns. If you recognize the pattern, you can solve faster.
